[
  {
    "session_id": "71990eb9-4517-4bb9-9ecc-addcc5ed7b46",
    "transcript_path": "/home/bryan/.claude/projects/-home-bryan-multi-agent-observability-system/71990eb9-4517-4bb9-9ecc-addcc5ed7b46.jsonl",
    "cwd": "/home/bryan/multi-agent-observability-system/.claude/hooks/utils/tts",
    "hook_event_name": "PostToolUse",
    "tool_name": "Bash",
    "tool_input": {
      "command": "cd /home/bryan/multi-agent-observability-system/.claude/hooks/utils/tts && python3 simple_lock_coordinator.py",
      "description": "Test simple TTS lock mechanism"
    },
    "tool_response": {
      "stdout": "Testing simple TTS lock mechanism...\nSpeaking message 1...\nResult: Success\nSpeaking message 2...\nResult: Success\nSpeaking message 3...\nResult: Success\n\nTest complete!",
      "stderr": "",
      "interrupted": false,
      "isImage": false
    }
  },
  {
    "session_id": "71990eb9-4517-4bb9-9ecc-addcc5ed7b46",
    "transcript_path": "/home/bryan/.claude/projects/-home-bryan-multi-agent-observability-system/71990eb9-4517-4bb9-9ecc-addcc5ed7b46.jsonl",
    "cwd": "/home/bryan/multi-agent-observability-system/.claude/hooks/utils/tts",
    "hook_event_name": "PreToolUse",
    "tool_name": "Write",
    "tool_input": {
      "file_path": "/home/bryan/multi-agent-observability-system/.claude/hooks/test_overlap_prevention.py",
      "content": "#!/usr/bin/env python3\n\"\"\"\nTest script to verify TTS overlap prevention.\nSimulates rapid hook calls that would normally cause audio overlap.\n\"\"\"\n\nimport json\nimport subprocess\nimport threading\nimport time\nfrom pathlib import Path\n\ndef trigger_hook(tool_name, description, delay=0):\n    \"\"\"Trigger a pre_tool_use hook after a delay.\"\"\"\n    time.sleep(delay)\n    \n    hook_path = Path(__file__).parent / \"pre_tool_use.py\"\n    \n    # Create test input\n    test_input = {\n        \"tool\": tool_name,\n        \"parameters\": {\n            \"description\": description,\n            \"prompt\": f\"Test {tool_name} operation\",\n            \"command\": \"npm install\" if tool_name == \"Bash\" else None\n        }\n    }\n    \n    # Run the hook\n    process = subprocess.Popen(\n        [\"python3\", str(hook_path)],\n        stdin=subprocess.PIPE,\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n        text=True\n    )\n    \n    stdout, stderr = process.communicate(input=json.dumps(test_input))\n    \n    print(f\"[{time.time():.2f}] Triggered {tool_name}: {description}\")\n    if process.returncode != 0:\n        print(f\"  \u274c Error: {stderr}\")\n    else:\n        print(f\"  \u2705 Success\")\n\ndef main():\n    \"\"\"Run overlap prevention test.\"\"\"\n    print(\"\ud83e\uddea Testing TTS Overlap Prevention\")\n    print(\"This will trigger multiple hooks in rapid succession.\")\n    print(\"Listen for audio overlap - messages should play sequentially, not simultaneously.\\n\")\n    \n    # Create threads to simulate concurrent hook calls\n    threads = []\n    \n    # Scenario 1: Multiple Task delegations\n    print(\"Scenario 1: Multiple Task delegations (should hear sequentially)\")\n    for i in range(3):\n        t = threading.Thread(\n            target=trigger_hook,\n            args=(\"Task\", f\"Task delegation {i+1}\", i * 0.1)  # Very small delays\n        )\n        threads.append(t)\n        t.start()\n    \n    # Wait for threads to complete\n    for t in threads:\n        t.join()\n    \n    time.sleep(3)  # Pause between scenarios\n    \n    # Scenario 2: Mixed operations triggered simultaneously\n    print(\"\\nScenario 2: Mixed operations (should hear sequentially)\")\n    threads = []\n    \n    operations = [\n        (\"Task\", \"Code review task\"),\n        (\"Bash\", \"Long running build\"),\n        (\"MultiEdit\", \"Bulk file changes\"),\n        (\"mcp__qdrant__qdrant_store\", \"Memory storage\")\n    ]\n    \n    for op, desc in operations:\n        t = threading.Thread(\n            target=trigger_hook,\n            args=(op, desc, 0)  # All at once!\n        )\n        threads.append(t)\n        t.start()\n    \n    # Wait for all to complete\n    for t in threads:\n        t.join()\n    \n    print(\"\\n\u2705 Test complete!\")\n    print(\"\\nExpected behavior:\")\n    print(\"- All messages should play sequentially, not overlapping\")\n    print(\"- Each message should complete before the next starts\")\n    print(\"- No audio artifacts or cut-offs\")\n    \n    print(\"\\nIf you heard overlap, the coordination mechanism needs adjustment.\")\n\nif __name__ == \"__main__\":\n    main()"
    }
  },
  {
    "session_id": "71990eb9-4517-4bb9-9ecc-addcc5ed7b46",
    "transcript_path": "/home/bryan/.claude/projects/-home-bryan-multi-agent-observability-system/71990eb9-4517-4bb9-9ecc-addcc5ed7b46.jsonl",
    "cwd": "/home/bryan/multi-agent-observability-system/.claude/hooks/utils/tts",
    "hook_event_name": "PostToolUse",
    "tool_name": "Write",
    "tool_input": {
      "file_path": "/home/bryan/multi-agent-observability-system/.claude/hooks/test_overlap_prevention.py",
      "content": "#!/usr/bin/env python3\n\"\"\"\nTest script to verify TTS overlap prevention.\nSimulates rapid hook calls that would normally cause audio overlap.\n\"\"\"\n\nimport json\nimport subprocess\nimport threading\nimport time\nfrom pathlib import Path\n\ndef trigger_hook(tool_name, description, delay=0):\n    \"\"\"Trigger a pre_tool_use hook after a delay.\"\"\"\n    time.sleep(delay)\n    \n    hook_path = Path(__file__).parent / \"pre_tool_use.py\"\n    \n    # Create test input\n    test_input = {\n        \"tool\": tool_name,\n        \"parameters\": {\n            \"description\": description,\n            \"prompt\": f\"Test {tool_name} operation\",\n            \"command\": \"npm install\" if tool_name == \"Bash\" else None\n        }\n    }\n    \n    # Run the hook\n    process = subprocess.Popen(\n        [\"python3\", str(hook_path)],\n        stdin=subprocess.PIPE,\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n        text=True\n    )\n    \n    stdout, stderr = process.communicate(input=json.dumps(test_input))\n    \n    print(f\"[{time.time():.2f}] Triggered {tool_name}: {description}\")\n    if process.returncode != 0:\n        print(f\"  \u274c Error: {stderr}\")\n    else:\n        print(f\"  \u2705 Success\")\n\ndef main():\n    \"\"\"Run overlap prevention test.\"\"\"\n    print(\"\ud83e\uddea Testing TTS Overlap Prevention\")\n    print(\"This will trigger multiple hooks in rapid succession.\")\n    print(\"Listen for audio overlap - messages should play sequentially, not simultaneously.\\n\")\n    \n    # Create threads to simulate concurrent hook calls\n    threads = []\n    \n    # Scenario 1: Multiple Task delegations\n    print(\"Scenario 1: Multiple Task delegations (should hear sequentially)\")\n    for i in range(3):\n        t = threading.Thread(\n            target=trigger_hook,\n            args=(\"Task\", f\"Task delegation {i+1}\", i * 0.1)  # Very small delays\n        )\n        threads.append(t)\n        t.start()\n    \n    # Wait for threads to complete\n    for t in threads:\n        t.join()\n    \n    time.sleep(3)  # Pause between scenarios\n    \n    # Scenario 2: Mixed operations triggered simultaneously\n    print(\"\\nScenario 2: Mixed operations (should hear sequentially)\")\n    threads = []\n    \n    operations = [\n        (\"Task\", \"Code review task\"),\n        (\"Bash\", \"Long running build\"),\n        (\"MultiEdit\", \"Bulk file changes\"),\n        (\"mcp__qdrant__qdrant_store\", \"Memory storage\")\n    ]\n    \n    for op, desc in operations:\n        t = threading.Thread(\n            target=trigger_hook,\n            args=(op, desc, 0)  # All at once!\n        )\n        threads.append(t)\n        t.start()\n    \n    # Wait for all to complete\n    for t in threads:\n        t.join()\n    \n    print(\"\\n\u2705 Test complete!\")\n    print(\"\\nExpected behavior:\")\n    print(\"- All messages should play sequentially, not overlapping\")\n    print(\"- Each message should complete before the next starts\")\n    print(\"- No audio artifacts or cut-offs\")\n    \n    print(\"\\nIf you heard overlap, the coordination mechanism needs adjustment.\")\n\nif __name__ == \"__main__\":\n    main()"
    },
    "tool_response": {
      "type": "create",
      "filePath": "/home/bryan/multi-agent-observability-system/.claude/hooks/test_overlap_prevention.py",
      "content": "#!/usr/bin/env python3\n\"\"\"\nTest script to verify TTS overlap prevention.\nSimulates rapid hook calls that would normally cause audio overlap.\n\"\"\"\n\nimport json\nimport subprocess\nimport threading\nimport time\nfrom pathlib import Path\n\ndef trigger_hook(tool_name, description, delay=0):\n    \"\"\"Trigger a pre_tool_use hook after a delay.\"\"\"\n    time.sleep(delay)\n    \n    hook_path = Path(__file__).parent / \"pre_tool_use.py\"\n    \n    # Create test input\n    test_input = {\n        \"tool\": tool_name,\n        \"parameters\": {\n            \"description\": description,\n            \"prompt\": f\"Test {tool_name} operation\",\n            \"command\": \"npm install\" if tool_name == \"Bash\" else None\n        }\n    }\n    \n    # Run the hook\n    process = subprocess.Popen(\n        [\"python3\", str(hook_path)],\n        stdin=subprocess.PIPE,\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n        text=True\n    )\n    \n    stdout, stderr = process.communicate(input=json.dumps(test_input))\n    \n    print(f\"[{time.time():.2f}] Triggered {tool_name}: {description}\")\n    if process.returncode != 0:\n        print(f\"  \u274c Error: {stderr}\")\n    else:\n        print(f\"  \u2705 Success\")\n\ndef main():\n    \"\"\"Run overlap prevention test.\"\"\"\n    print(\"\ud83e\uddea Testing TTS Overlap Prevention\")\n    print(\"This will trigger multiple hooks in rapid succession.\")\n    print(\"Listen for audio overlap - messages should play sequentially, not simultaneously.\\n\")\n    \n    # Create threads to simulate concurrent hook calls\n    threads = []\n    \n    # Scenario 1: Multiple Task delegations\n    print(\"Scenario 1: Multiple Task delegations (should hear sequentially)\")\n    for i in range(3):\n        t = threading.Thread(\n            target=trigger_hook,\n            args=(\"Task\", f\"Task delegation {i+1}\", i * 0.1)  # Very small delays\n        )\n        threads.append(t)\n        t.start()\n    \n    # Wait for threads to complete\n    for t in threads:\n        t.join()\n    \n    time.sleep(3)  # Pause between scenarios\n    \n    # Scenario 2: Mixed operations triggered simultaneously\n    print(\"\\nScenario 2: Mixed operations (should hear sequentially)\")\n    threads = []\n    \n    operations = [\n        (\"Task\", \"Code review task\"),\n        (\"Bash\", \"Long running build\"),\n        (\"MultiEdit\", \"Bulk file changes\"),\n        (\"mcp__qdrant__qdrant_store\", \"Memory storage\")\n    ]\n    \n    for op, desc in operations:\n        t = threading.Thread(\n            target=trigger_hook,\n            args=(op, desc, 0)  # All at once!\n        )\n        threads.append(t)\n        t.start()\n    \n    # Wait for all to complete\n    for t in threads:\n        t.join()\n    \n    print(\"\\n\u2705 Test complete!\")\n    print(\"\\nExpected behavior:\")\n    print(\"- All messages should play sequentially, not overlapping\")\n    print(\"- Each message should complete before the next starts\")\n    print(\"- No audio artifacts or cut-offs\")\n    \n    print(\"\\nIf you heard overlap, the coordination mechanism needs adjustment.\")\n\nif __name__ == \"__main__\":\n    main()",
      "structuredPatch": []
    }
  },
  {
    "session_id": "71990eb9-4517-4bb9-9ecc-addcc5ed7b46",
    "transcript_path": "/home/bryan/.claude/projects/-home-bryan-multi-agent-observability-system/71990eb9-4517-4bb9-9ecc-addcc5ed7b46.jsonl",
    "cwd": "/home/bryan/multi-agent-observability-system/.claude/hooks/utils/tts",
    "hook_event_name": "PreToolUse",
    "tool_name": "Bash",
    "tool_input": {
      "command": "cd /home/bryan/multi-agent-observability-system/.claude/hooks && python3 test_overlap_prevention.py",
      "description": "Test TTS overlap prevention"
    }
  }
]